## 第二章 传输层 TCP、UDP

### UDP

- 定义：是一种简单的、不可靠的用户数据包协议(User Datagram Protocol)
- 特性：是一种`无连接`的协议，不能保证数据报最终是否达到用户


### TCP

- 定义：是一种复杂的、可靠的字节流协议，也叫传输控制协议(Tranmission Control Protocol)
- 特性：面向`连接`的协议，关注可靠性、流量控制等特性，具体如下：
    * 连接：数据双方在连接的基础上进行通信交互
    * 可靠性： 发送数据后，要求对端返回一个确认，否则在一定次数范围内进行重传；发送的分节都会关联一个序号，通过序号保证最终给到应用的数据有序。
    * 流量控制：总是告知对端在任意时刻能够接受多少字节的数据，称之为`通告窗口`，实时变化。
    * 全双工：任意时刻数据双向流动
- 建立连接(三次握手)
    * Q：为什么不用四次握手？
    * A：第二次的ack和syn可以合并，效率更高
    * Q：为什么不用二次握手？
    * A：syn用于同步客户端和服务的发送起始序号，若只有两次握手，则至多只有一方的发送起始序号被同步
    * Q：三次握手的过程中交互了哪些信息？
    * A：通告对方最大分节的大小（MMS）、通告窗口规模大小、时间戳选项（避免失而复现的分节造成数据损坏）
```
    // 三次握手
    client  --->  server    (SYN=1 seq=x)
    client  <---  server    (ACK=1 SYN=1 seq=y ack=x+1) 服务端确认可以像我发送序列x+1的序号了，同时告诉你我的序号是y
    client  --->  server    (ACK=1 req=x+1 ack=y+1) 客户端确认可以像我发送y+1的数据了
    
    // 发送数据
    client  --->  server    (req=x+1) 这里之所以还是x+1 是因为上一个回复的ack不携带数据 不用消耗请求序号     
```
- 关闭连接（四次挥手）

##第五章 TCP客户端与服务端实例

### 僵尸进程

### 孤儿进程

## 第六章 I/O复用

### I/O模型

输入操作包含两个部分：1、等待数据准备好 2、从内核空间拷贝数据到进程空间    
- 阻塞式I/O: 以udp为例,应用进程将阻塞在recvFrom的系统调用之上，当数据到达之后，再从内核空间拷贝数据到进程空间。
- 非阻塞式I/O: 非阻塞I/O则指进行系统调用recvFrom的时候，应用进程不阻塞，无数据的情况取代以一个错误码返回，应用进程需要不断询问数据是否就绪，cpu利用率较低。
- I/O复用: select/poll属于io复用，阻塞于select的系统调用之上，一个或者多个连接符就绪后，再调用recvfrom取数据    
    * 缺点: 阻塞在两个系统调用 效率不一定比阻塞式的高
    * 优点: 可以等待多个连接符就绪
- 信号驱动式I/O
- 异步I/O

简单来说：上面的五种IO模型，前4种都将阻塞于从内核空间到应用空间的数据读取之上，属于同步IO，最后一种待所有操作就绪之后通知应用进程，属于异步IO。同步和异步的主要区别在于第二步是否阻塞。

### epoll
- 水平模式
- 垂直模式

```c++
typedef union epoll_data {
   void        *ptr;
   int          fd;
   uint32_t     u32;
   uint64_t     u64;
} epoll_data_t;

struct epoll_event {
   uint32_t     events;      /* Epoll events EPOLLIN/EPOLLOUT and so on*/
   epoll_data_t data;        /* User data variable */
};
```

### select和epoll对比
- select
    * 缺点：连接描述符有限；每次select的系统调用，都需要将所有的连接描述符拷贝到内核空间，效率低下；    
    一个或多个连接就绪之后，需要通过遍历判定FD_ISSET的方式判定，不适用于连接量大，但是只有少量连接符有数据的情况
    * 优点：select移植性更好，多平台适用；对阻塞超时的判定时间更加精准，ms级别
- epoll
    * 优点：连接量大；不必轮询判定数据就绪状态，效率更高；通过epoll_ctrl进行连接符的添加删除、事件动作的监听(EPOLLIN/EPOLLOUT)，只需要像内核空间拷贝一次数据，存储于内核的红黑树上，    
    并且在有事件发生时将对应的连接符以链表的形式（epoll_event*）返回,不用轮询。
    * 缺点：只在linux系统特定版本存在；描述符状态频繁变换的情况，epoll_ctrl调用较多，系统性能浪费。
    * 适用场景：长连接的情况，并发监听的描述符较多。
    

    
    

