# fucking leetcode
  开始走上刷题的道路，这里按照[cspiration](https://cspiration.com/leetcodeClassification)上的顺序进行刷，有两个好处：一是本身tag的分类更为合理，由简到难，数据结构循序渐进;另外就是每个tag里面的题目都是经过挑选，主要应该是一些典型题，且题目前后有一定的关联，可以抽取成某种模式：
    
      关于模式，设计模式这本书里说，模式就是在生活中常遇到的一类问题，以及这类问题的一些固定解法。
  下面，开始吧。。不一定每个题目都会详细记录，有些屁话想说的就会放在这个里面。其他的我觉得还是主要去看代码里面吧。
 ## 数组(按照顺序记录)

 - 26 删除数组中的重复项目
   - 思路：数组有序，主要利用快慢指针删除相邻的相同元素，只保留一个
   - 状态：
     - 开始：慢指针指向开始，快指针指向其后一位
     - 移动：快指针若遇上相同的元素，加快移动一位；直到遇见首个不相等的元素，交换**慢指针位置下一个元素**和当前快指针的元素（之所以是下一个，是因为重复的元素要保留一个）
     - 结束：快指针指向数组尾部
- 27 删除数组中指定元素
  - 思路：数组无顺，仍然利用快慢指针
  - 状态：
    - 开始：快慢指针均从0开始
    - 移动：当前快指针所指向元素等于目标元素，加快移动一位；直到遇上首个不等于目标的元素，交换慢指针和快指针位置的元素,然后递增当前的慢指针位置
    - 结束：快指针指向数组尾部 
  - 其他：注意和删除重复元素的进行对比
- 80 删除数组中大于2个的重复项目 至多保留2个
  - 思路：对比26 一开始容易去对比quick和slow所指的位置，这样就有很多状态需要维护，而且容易出错；这里采用取巧的方式为：对比quick位置和slow-1位置的元素不同的话就进行替换，这样就保留了至多两个的相同元素。
  - 其他：核心代码(一顿操作猛如虎，一看答案我最土。。。。说的就是这题)
    ```C++
      for (size_t quick = 2; quick < nums.size(); ++quick) {
      // 和之前的26题对比 他的保留两个重复项的状态是由和slow的前一个元素对比完成
      if (nums[quick] != nums[slow - 1]) {
        nums[++slow] = nums[quick];
      }
    }
    ```
- 189 数组中元素循环右移k个位置
  - 思路：这个题解法比较多，
    - 常规的暴力法：每次只移动一个位置，last存储下上个位置的变量，但是有超时的情况发生。
    - 新空间法：直接将元素放到一个新的数组中应该在的位置`new[(i+k)%size] = nums[i]`,最后再逐个塞回去
    - 多次旋转：
      ```C++
      // 高端方法 offset =  k % size 个元素会被移动到头部
      // 第一次全部反转 1 2 3 4 5 6 7 -> 7 6 5 4 3 2 1
      // 前offset个反转 7 6 5 4 3 2 1 -> 5 6 7 4 3 2 1
      // 后size-offset个反转 5 6 7 4 3 2 1 -> 5 6 7 1 2 3 4
      if (nums.empty()) return;
      int length = nums.size();
      int offset = k % length;
      Reserver(nums, 0, length - 1);
      Reserver(nums, 0, offset - 1);
      Reserver(nums, offset, length - 1);
      ```